---
import DocsLayout from '../../../layouts/DocsLayout.astro';

const content = "<p>\n> Autonomous health monitoring and recovery in Gas Town.\n</p>\n<h2>Overview</h2>\n<p>\nGas Town uses a three-tier watchdog chain for autonomous health monitoring:\n</p>\n<p>\n<pre><code class=\"language-text\">Daemon (Go process)          ← Dumb transport, 3-min heartbeat\n    │\n    └─► Boot (AI agent)       ← Intelligent triage, fresh each tick\n            │\n            └─► Deacon (AI agent)  ← Continuous patrol, long-running\n                    │\n                    └─► Witnesses &amp; Refineries  ← Per-rig agents</code></pre>\n</p>\n<strong>Key insight</strong>: The daemon is mechanical (can't reason), but health decisions need\n<p>\nintelligence (is the agent stuck or just thinking?). Boot bridges this gap.\n</p>\n<h2>Design Rationale: Why Two Agents?</h2>\n<h3>The Problem</h3>\n<p>\nThe daemon needs to ensure the Deacon is healthy, but:\n</p>\n<p>\n1. <strong>Daemon can't reason</strong> - It's Go code following the ZFC principle (don't reason\n   about other agents). It can check \"is session alive?\" but not \"is agent stuck?\"\n</p>\n<p>\n2. <strong>Waking costs context</strong> - Each time you spawn an AI agent, you consume context\n   tokens. In idle towns, waking Deacon every 3 minutes wastes resources.\n</p>\n<p>\n3. <strong>Observation requires intelligence</strong> - Distinguishing \"agent composing large\n   artifact\" from \"agent hung on tool prompt\" requires reasoning.\n</p>\n<h3>The Solution: Boot as Triage</h3>\n<p>\nBoot is a narrow, ephemeral AI agent that:\n</p>\n<ul><li>Runs fresh each daemon tick (no accumulated context debt)</li>\n<li>Makes a single decision: should Deacon wake?</li>\n<li>Exits immediately after deciding</li>\n</ul>\n<p>\nThis gives us intelligent triage without the cost of keeping a full AI running.\n</p>\n<h3>Why Not Merge Boot into Deacon?</h3>\n<p>\nWe could have Deacon handle its own \"should I be awake?\" logic, but:\n</p>\n<p>\n1. <strong>Deacon can't observe itself</strong> - A hung Deacon can't detect it's hung\n2. <strong>Context accumulation</strong> - Deacon runs continuously; Boot restarts fresh\n3. <strong>Cost in idle towns</strong> - Boot only costs tokens when it runs; Deacon costs\n   tokens constantly if kept alive\n</p>\n<h3>Why Not Replace with Go Code?</h3>\n<p>\nThe daemon could directly monitor agents without AI, but:\n</p>\n<p>\n1. <strong>Can't observe panes</strong> - Go code can't interpret tmux output semantically\n2. <strong>Can't distinguish stuck vs working</strong> - No reasoning about agent state\n3. <strong>Escalation is complex</strong> - When to notify? When to force-restart? AI handles\n   nuanced decisions better than hardcoded thresholds\n</p>\n<h2>Session Ownership</h2>\n<table><tr><td>Agent</td><td>Session Name</td><td>Location</td><td>Lifecycle</td></tr>\n</table>\n<table><tr><td>Daemon</td><td>(Go process)</td><td><code>~/gt/daemon/</code></td><td>Persistent, auto-restart</td></tr>\n<tr><td>Boot</td><td><code>gt-boot</code></td><td><code>~/gt/deacon/dogs/boot/</code></td><td>Ephemeral, fresh each tick</td></tr>\n<tr><td>Deacon</td><td><code>hq-deacon</code></td><td><code>~/gt/deacon/</code></td><td>Long-running, handoff loop</td></tr>\n</table>\n<strong>Critical</strong>: Boot runs in <code>gt-boot</code>, NOT <code>hq-deacon</code>. This prevents Boot\n<p>\nfrom conflicting with a running Deacon session.\n</p>\n<h2>Heartbeat Mechanics</h2>\n<h3>Daemon Heartbeat (3 minutes)</h3>\n<p>\nThe daemon runs a heartbeat tick every 3 minutes:\n</p>\n<p>\n<pre><code class=\"language-go\">func (d *Daemon) heartbeatTick() {\n    d.ensureBootRunning()           // 1. Spawn Boot for triage\n    d.checkDeaconHeartbeat()        // 2. Belt-and-suspenders fallback\n    d.ensureWitnessesRunning()      // 3. Witness health (checks tmux directly)\n    d.ensureRefineriesRunning()     // 4. Refinery health (checks tmux directly)\n    d.triggerPendingSpawns()        // 5. Bootstrap polecats\n    d.processLifecycleRequests()    // 6. Cycle/restart requests\n    // Agent state derived from tmux, not recorded in beads (gt-zecmc)\n}</code></pre>\n</p>\n<h3>Deacon Heartbeat (continuous)</h3>\n<p>\nThe Deacon updates <code>~/gt/deacon/heartbeat.json</code> at the start of each patrol cycle:\n</p>\n<p>\n<pre><code class=\"language-json\">{\n  &quot;timestamp&quot;: &quot;2026-01-02T18:30:00Z&quot;,\n  &quot;cycle&quot;: 42,\n  &quot;last_action&quot;: &quot;health-scan&quot;,\n  &quot;healthy_agents&quot;: 3,\n  &quot;unhealthy_agents&quot;: 0\n}</code></pre>\n</p>\n<h3>Heartbeat Freshness</h3>\n<table><tr><td>Age</td><td>State</td><td>Boot Action</td></tr>\n</table>\n<table><tr><td>< 5 min</td><td>Fresh</td><td>Nothing (Deacon active)</td></tr>\n<tr><td>5-15 min</td><td>Stale</td><td>Nudge if pending mail</td></tr>\n<tr><td>> 15 min</td><td>Very stale</td><td>Wake (Deacon may be stuck)</td></tr>\n</table>\n<h2>Boot Decision Matrix</h2>\n<p>\nWhen Boot runs, it observes:\n</p>\n<ul><li>Is Deacon session alive?</li>\n<li>How old is Deacon's heartbeat?</li>\n<li>Is there pending mail for Deacon?</li>\n<li>What's in Deacon's tmux pane?</li>\n</ul>\n<p>\nThen decides:\n</p>\n<table><tr><td>Condition</td><td>Action</td><td>Command</td></tr>\n</table>\n<table><tr><td>Session dead</td><td>START</td><td>Exit; daemon calls <code>ensureDeaconRunning()</code></td></tr>\n<tr><td>Heartbeat > 15 min</td><td>WAKE</td><td><code>gt nudge deacon &quot;Boot wake: check your inbox&quot;</code></td></tr>\n<tr><td>Heartbeat 5-15 min + mail</td><td>NUDGE</td><td><code>gt nudge deacon &quot;Boot check-in: pending work&quot;</code></td></tr>\n<tr><td>Heartbeat fresh</td><td>NOTHING</td><td>Exit silently</td></tr>\n</table>\n<h2>Handoff Flow</h2>\n<h3>Deacon Handoff</h3>\n<p>\nThe Deacon runs continuous patrol cycles. After N cycles or high context:\n</p>\n<p>\n<pre><code class=\"language-text\">End of patrol cycle:\n    │\n    ├─ Squash wisp to digest (ephemeral → permanent)\n    ├─ Write summary to molecule state\n    └─ gt handoff -s &quot;Routine cycle&quot; -m &quot;Details&quot;\n        │\n        └─ Creates mail for next session</code></pre>\n</p>\n<p>\nNext daemon tick:\n<pre><code class=\"language-text\">Daemon → ensureDeaconRunning()\n    │\n    └─ Spawns fresh Deacon in gt-deacon\n        │\n        └─ SessionStart hook: gt mail check --inject\n            │\n            └─ Previous handoff mail injected\n                │\n                └─ Deacon reads and continues</code></pre>\n</p>\n<h3>Boot Handoff (Rare)</h3>\n<p>\nBoot is ephemeral - it exits after each tick. No persistent handoff needed.\n</p>\n<p>\nHowever, Boot uses a marker file to prevent double-spawning:\n</p>\n<ul><li>Marker: <code>~/gt/deacon/dogs/boot/.boot-running</code> (TTL: 5 minutes)</li>\n<li>Status: <code>~/gt/deacon/dogs/boot/.boot-status.json</code> (last action/result)</li>\n</ul>\n<p>\nIf the marker exists and is recent, daemon skips Boot spawn for that tick.\n</p>\n<h2>Degraded Mode</h2>\n<p>\nWhen tmux is unavailable, Gas Town enters degraded mode:\n</p>\n<table><tr><td>Capability</td><td>Normal</td><td>Degraded</td></tr>\n</table>\n<table><tr><td>Boot runs</td><td>As AI in tmux</td><td>As Go code (mechanical)</td></tr>\n<tr><td>Observe panes</td><td>Yes</td><td>No</td></tr>\n<tr><td>Nudge agents</td><td>Yes</td><td>No</td></tr>\n<tr><td>Start agents</td><td>tmux sessions</td><td>Direct spawn</td></tr>\n</table>\n<p>\nDegraded Boot triage is purely mechanical:\n</p>\n<ul><li>Session dead → start</li>\n<li>Heartbeat stale → restart</li>\n<li>No reasoning, just thresholds</li>\n</ul>\n<h2>Fallback Chain</h2>\n<p>\nMultiple layers ensure recovery:\n</p>\n<p>\n1. <strong>Boot triage</strong> - Intelligent observation, first line\n2. <strong>Daemon checkDeaconHeartbeat()</strong> - Belt-and-suspenders if Boot fails\n3. <strong>Tmux-based discovery</strong> - Daemon checks tmux sessions directly (no bead state)\n4. <strong>Human escalation</strong> - Mail to overseer for unrecoverable states\n</p>\n<h2>State Files</h2>\n<table><tr><td>File</td><td>Purpose</td><td>Updated By</td></tr>\n</table>\n<table><tr><td><code>deacon/heartbeat.json</code></td><td>Deacon freshness</td><td>Deacon (each cycle)</td></tr>\n<tr><td><code>deacon/dogs/boot/.boot-running</code></td><td>Boot in-progress marker</td><td>Boot spawn</td></tr>\n<tr><td><code>deacon/dogs/boot/.boot-status.json</code></td><td>Boot last action</td><td>Boot triage</td></tr>\n<tr><td><code>deacon/health-check-state.json</code></td><td>Agent health tracking</td><td><code>gt deacon health-check</code></td></tr>\n<tr><td><code>daemon/daemon.log</code></td><td>Daemon activity</td><td>Daemon</td></tr>\n<tr><td><code>daemon/daemon.pid</code></td><td>Daemon process ID</td><td>Daemon startup</td></tr>\n</table>\n<h2>Debugging</h2>\n<p>\n<pre><code class=\"language-bash\"># Check Deacon heartbeat\ncat ~/gt/deacon/heartbeat.json | jq .\n\n# Check Boot status\ncat ~/gt/deacon/dogs/boot/.boot-status.json | jq .\n\n# View daemon log\ntail -f ~/gt/daemon/daemon.log\n\n# Manual Boot run\ngt boot triage\n\n# Manual Deacon health check\ngt deacon health-check</code></pre>\n</p>\n<h2>Common Issues</h2>\n<h3>Boot Spawns in Wrong Session</h3>\n<strong>Symptom</strong>: Boot runs in <code>hq-deacon</code> instead of <code>gt-boot</code>\n<strong>Cause</strong>: Session name confusion in spawn code\n<strong>Fix</strong>: Ensure <code>gt boot triage</code> specifies <code>--session=gt-boot</code>\n<h3>Zombie Sessions Block Restart</h3>\n<strong>Symptom</strong>: tmux session exists but Claude is dead\n<strong>Cause</strong>: Daemon checks session existence, not process health\n<strong>Fix</strong>: Kill zombie sessions before recreating: <code>gt session kill hq-deacon</code>\n<h3>Status Shows Wrong State</h3>\n<strong>Symptom</strong>: <code>gt status</code> shows wrong state for agents\n<strong>Cause</strong>: Previously bead state and tmux state could diverge\n<strong>Fix</strong>: As of gt-zecmc, status derives state from tmux directly (no bead state for\n<p>\nobservable conditions like running/stopped). Non-observable states (stuck, awaiting-gate)\nare still stored in beads.\n</p>\n<h2>Design Decision: Keep Separation</h2>\n<p>\nThe issue [gt-1847v] considered three options:\n</p>\n<h3>Option A: Keep Boot/Deacon Separation (CHOSEN)</h3>\n<ul><li>Boot is ephemeral, spawns fresh each heartbeat</li>\n<li>Boot runs in <code>gt-boot</code>, exits after triage</li>\n<li>Deacon runs in <code>hq-deacon</code>, continuous patrol</li>\n<li>Clear session boundaries, clear lifecycle</li>\n</ul>\n<strong>Verdict</strong>: This is the correct design. The implementation needs fixing, not the architecture.\n<h3>Option B: Merge Boot into Deacon (Rejected)</h3>\n<ul><li>Single <code>hq-deacon</code> session handles everything</li>\n<li>Deacon checks \"should I be awake?\" internally</li>\n</ul>\n<strong>Why rejected</strong>:\n<ul><li>Deacon can't observe itself (hung Deacon can't detect hang)</li>\n<li>Context accumulates even when idle (cost in quiet towns)</li>\n<li>No external watchdog means no recovery from Deacon failure</li>\n</ul>\n<h3>Option C: Replace with Go Watchdog (Rejected)</h3>\n<ul><li>Daemon directly monitors witness/refinery</li>\n<li>No Boot, no Deacon AI for health checks</li>\n<li>AI agents only for complex decisions</li>\n</ul>\n<strong>Why rejected</strong>:\n<ul><li>Go code can't interpret tmux pane output semantically</li>\n<li>Can't distinguish \"stuck\" from \"thinking deeply\"</li>\n<li>Loses the intelligent triage that makes the system resilient</li>\n<li>Escalation decisions are nuanced (when to notify? force-restart?)</li>\n</ul>\n<h3>Implementation Fixes Needed</h3>\n<p>\nThe separation is correct; these bugs need fixing:\n</p>\n<p>\n1. <strong>Session confusion</strong> (gt-sgzsb): Boot spawns in wrong session\n2. <strong>Zombie blocking</strong> (gt-j1i0r): Daemon can't kill zombie sessions\n3. ~~<strong>Status mismatch</strong> (gt-doih4): Bead vs tmux state divergence~~ → FIXED in gt-zecmc\n4. <strong>Ensure semantics</strong> (gt-ekc5u): Start should kill zombies first\n</p>\n<h2>Summary</h2>\n<p>\nThe watchdog chain provides autonomous recovery:\n</p>\n<ul><li><strong>Daemon</strong>: Mechanical heartbeat, spawns Boot</li>\n<li><strong>Boot</strong>: Intelligent triage, decides Deacon fate</li>\n<li><strong>Deacon</strong>: Continuous patrol, monitors workers</li>\n</ul>\n<p>\nBoot exists because the daemon can't reason and Deacon can't observe itself.\nThe separation costs complexity but enables:\n</p>\n<p>\n1. <strong>Intelligent triage</strong> without constant AI cost\n2. <strong>Fresh context</strong> for each triage decision\n3. <strong>Graceful degradation</strong> when tmux unavailable\n4. <strong>Multiple fallback</strong> layers for reliability\n</p>";
---

<DocsLayout title="Daemon/Boot/Deacon Watchdog Chain" description="> Autonomous health monitoring and recovery in Gas Town.">
  <div class="markdown-content" set:html={content} />
</DocsLayout>
