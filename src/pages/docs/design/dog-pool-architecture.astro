---
import DocsLayout from '../../../layouts/DocsLayout.astro';

const content = "<p>\n> Design document for gt-fsld8\n</p>\n<h2>Problem Statement</h2>\n<p>\nBoot needs to run multiple shutdown-dance molecules concurrently when multiple death\nwarrants are issued. The current hook design only allows one molecule per agent.\n</p>\n<p>\nExample scenario:\n</p>\n<ul><li>Warrant 1: Kill stuck polecat Toast (60s into interrogation)</li>\n<li>Warrant 2: Kill stuck polecat Shadow (just started)</li>\n<li>Warrant 3: Kill stuck witness (120s into interrogation)</li>\n</ul>\n<p>\nAll three need concurrent tracking, independent timeouts, and separate outcomes.\n</p>\n<h2>Design Decision: Lightweight State Machines</h2>\n<p>\nAfter analyzing the options, the shutdown-dance does NOT need Claude sessions.\nThe dance is a deterministic state machine:\n</p>\n<p>\n<pre><code class=\"language-text\">WARRANT -&gt; INTERROGATE -&gt; EVALUATE -&gt; PARDON|EXECUTE</code></pre>\n</p>\n<p>\nEach step is mechanical:\n</p>\n<ol><li>Send a tmux message (no LLM needed)</li>\n<li>Wait for timeout or response (timer)</li>\n<li>Check tmux output for ALIVE keyword (string match)</li>\n<li>Repeat or terminate</li>\n</ol>\n<strong>Decision</strong>: Dogs are lightweight Go routines, not Claude sessions.\n<h2>Architecture Overview</h2>\n<p>\n<pre><code class=\"language-text\">┌────────────────────────────────────────────────────────────────────┐\n│                             BOOT                                    │\n│                     (Claude session in tmux)                        │\n│                                                                     │\n│  ┌──────────────────────────────────────────────────────────────┐  │\n│  │                      Dog Manager                              │  │\n│  │                                                               │  │\n│  │   Pool: [Dog1, Dog2, Dog3, ...]  (goroutines + state files)  │  │\n│  │                                                               │  │\n│  │   allocate() → Dog                                           │  │\n│  │   release(Dog)                                               │  │\n│  │   status() → []DogStatus                                     │  │\n│  └──────────────────────────────────────────────────────────────┘  │\n│                                                                     │\n│  Boot's job:                                                       │\n│  - Watch for warrants (file or event)                              │\n│  - Allocate dog from pool                                          │\n│  - Monitor dog progress                                            │\n│  - Handle dog completion/failure                                   │\n│  - Report results                                                  │\n└────────────────────────────────────────────────────────────────────┘</code></pre>\n</p>\n<h2>Dog Structure</h2>\n<p>\n<pre><code class=\"language-go\">// Dog represents a shutdown-dance executor\ntype Dog struct {\n    ID        string            // Unique ID (e.g., &quot;dog-1704567890123&quot;)\n    Warrant   *Warrant          // The death warrant being processed\n    State     ShutdownDanceState\n    Attempt   int               // Current interrogation attempt (1-3)\n    StartedAt time.Time\n    StateFile string            // Persistent state: ~/gt/deacon/dogs/active/&lt;id&gt;.json\n}\n\ntype ShutdownDanceState string\n\nconst (\n    StateIdle          ShutdownDanceState = &quot;idle&quot;\n    StateInterrogating ShutdownDanceState = &quot;interrogating&quot;  // Sent message, waiting\n    StateEvaluating    ShutdownDanceState = &quot;evaluating&quot;     // Checking response\n    StatePardoned      ShutdownDanceState = &quot;pardoned&quot;       // Session responded\n    StateExecuting     ShutdownDanceState = &quot;executing&quot;      // Killing session\n    StateComplete      ShutdownDanceState = &quot;complete&quot;       // Done, ready for cleanup\n    StateFailed        ShutdownDanceState = &quot;failed&quot;         // Dog crashed/errored\n)\n\ntype Warrant struct {\n    ID        string    // Bead ID for the warrant\n    Target    string    // Session to interrogate (e.g., &quot;gt-gastown-Toast&quot;)\n    Reason    string    // Why warrant was issued\n    Requester string    // Who filed the warrant\n    FiledAt   time.Time\n}</code></pre>\n</p>\n<h2>Pool Design</h2>\n<h3>Fixed Pool Size</h3>\n<strong>Decision</strong>: Fixed pool of 5 dogs, configurable via environment.\n<p>\nRationale:\n</p>\n<ul><li>Dynamic sizing adds complexity without clear benefit</li>\n<li>5 concurrent shutdown dances handles worst-case scenarios</li>\n<li>If pool exhausted, warrants queue (better than infinite dog spawning)</li>\n<li>Memory footprint is negligible (goroutines + small state files)</li>\n</ul>\n<p>\n<pre><code class=\"language-go\">const (\n    DefaultPoolSize = 5\n    MaxPoolSize     = 20\n)\n\ntype DogPool struct {\n    mu       sync.Mutex\n    dogs     []*Dog           // All dogs in pool\n    idle     chan *Dog        // Channel of available dogs\n    active   map[string]*Dog  // ID -&gt; Dog for active dogs\n    stateDir string           // ~/gt/deacon/dogs/active/\n}\n\nfunc (p *DogPool) Allocate(warrant *Warrant) (*Dog, error) {\n    select {\n    case dog := &lt;-p.idle:\n        dog.Warrant = warrant\n        dog.State = StateInterrogating\n        dog.Attempt = 1\n        dog.StartedAt = time.Now()\n        p.active[dog.ID] = dog\n        return dog, nil\n    default:\n        return nil, ErrPoolExhausted\n    }\n}\n\nfunc (p *DogPool) Release(dog *Dog) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n    delete(p.active, dog.ID)\n    dog.Reset()\n    p.idle &lt;- dog\n}</code></pre>\n</p>\n<h3>Why Not Dynamic Pool?</h3>\n<p>\nConsidered but rejected:\n</p>\n<ul><li>Adding dogs on demand increases complexity</li>\n<li>No clear benefit - warrants rarely exceed 5 concurrent</li>\n<li>If needed, raise DefaultPoolSize</li>\n<li>Simpler to reason about fixed resources</li>\n</ul>\n<h2>Communication: State Files + Events</h2>\n<h3>State Persistence</h3>\n<p>\nEach active dog writes state to <code>~/gt/deacon/dogs/active/&lt;id&gt;.json</code>:\n</p>\n<p>\n<pre><code class=\"language-json\">{\n  &quot;id&quot;: &quot;dog-1704567890123&quot;,\n  &quot;warrant&quot;: {\n    &quot;id&quot;: &quot;gt-abc123&quot;,\n    &quot;target&quot;: &quot;gt-gastown-Toast&quot;,\n    &quot;reason&quot;: &quot;no_response_health_check&quot;,\n    &quot;requester&quot;: &quot;deacon&quot;,\n    &quot;filed_at&quot;: &quot;2026-01-07T20:15:00Z&quot;\n  },\n  &quot;state&quot;: &quot;interrogating&quot;,\n  &quot;attempt&quot;: 2,\n  &quot;started_at&quot;: &quot;2026-01-07T20:15:00Z&quot;,\n  &quot;last_message_at&quot;: &quot;2026-01-07T20:16:00Z&quot;,\n  &quot;next_timeout&quot;: &quot;2026-01-07T20:18:00Z&quot;\n}</code></pre>\n</p>\n<h3>Boot Monitoring</h3>\n<p>\nBoot monitors dogs via:\n</p>\n<ol><li><strong>Polling</strong>: <code>gt dog status --active</code> every tick</li>\n<li><strong>Completion files</strong>: Dogs write <code>&lt;id&gt;.done</code> when complete</li>\n</ol>\n<p>\n<pre><code class=\"language-go\">type DogResult struct {\n    DogID    string\n    Warrant  *Warrant\n    Outcome  DogOutcome  // pardoned | executed | failed\n    Duration time.Duration\n    Details  string\n}\n\ntype DogOutcome string\n\nconst (\n    OutcomePardoned DogOutcome = &quot;pardoned&quot;  // Session responded\n    OutcomeExecuted DogOutcome = &quot;executed&quot;  // Session killed\n    OutcomeFailed   DogOutcome = &quot;failed&quot;    // Dog crashed\n)</code></pre>\n</p>\n<h3>Why Not Mail?</h3>\n<p>\nConsidered but rejected for dog<->boot communication:\n</p>\n<ul><li>Mail is async, poll-based - adds latency</li>\n<li>State files are simpler for local coordination</li>\n<li>Dogs don't need complex inter-agent communication</li>\n<li>Keep mail for external coordination (Witness, Mayor)</li>\n</ul>\n<h2>Shutdown Dance State Machine</h2>\n<p>\nEach dog executes this state machine:\n</p>\n<p>\n<pre><code class=\"language-text\">┌─────────────────────────────────────────┐\n                    │                                         │\n                    ▼                                         │\n    ┌───────────────────────────┐                            │\n    │     INTERROGATING         │                            │\n    │                           │                            │\n    │  1. Send health check     │                            │\n    │  2. Start timeout timer   │                            │\n    └───────────┬───────────────┘                            │\n                │                                             │\n                │ timeout or response                         │\n                ▼                                             │\n    ┌───────────────────────────┐                            │\n    │      EVALUATING           │                            │\n    │                           │                            │\n    │  Check tmux output for    │                            │\n    │  ALIVE keyword            │                            │\n    └───────────┬───────────────┘                            │\n                │                                             │\n        ┌───────┴───────┐                                    │\n        │               │                                    │\n        ▼               ▼                                    │\n   [ALIVE found]   [No ALIVE]                               │\n        │               │                                    │\n        │               │ attempt &lt; 3?                       │\n        │               ├──────────────────────────────────→─┘\n        │               │ yes: attempt++, longer timeout\n        │               │\n        │               │ no: attempt == 3\n        ▼               ▼\n    ┌─────────┐    ┌─────────────┐\n    │ PARDONED│    │  EXECUTING  │\n    │         │    │             │\n    │ Cancel  │    │ Kill tmux   │\n    │ warrant │    │ session     │\n    └────┬────┘    └──────┬──────┘\n         │                │\n         └────────┬───────┘\n                  │\n                  ▼\n         ┌────────────────┐\n         │    COMPLETE    │\n         │                │\n         │  Write result  │\n         │  Release dog   │\n         └────────────────┘</code></pre>\n</p>\n<h3>Timeout Gates</h3>\n<table><tr><td>Attempt</td><td>Timeout</td><td>Cumulative Wait</td></tr>\n</table>\n<table><tr><td>1</td><td>60s</td><td>60s</td></tr>\n<tr><td>2</td><td>120s</td><td>180s (3 min)</td></tr>\n<tr><td>3</td><td>240s</td><td>420s (7 min)</td></tr>\n</table>\n<h3>Health Check Message</h3>\n<p>\n<pre><code class=\"language-text\">[DOG] HEALTH CHECK: Session {target}, respond ALIVE within {timeout}s or face termination.\nWarrant reason: {reason}\nFiled by: {requester}\nAttempt: {attempt}/3</code></pre>\n</p>\n<h3>Response Detection</h3>\n<p>\n<pre><code class=\"language-go\">func (d *Dog) CheckForResponse() bool {\n    tm := tmux.NewTmux()\n    output, err := tm.CapturePane(d.Warrant.Target, 50) // Last 50 lines\n    if err != nil {\n        return false\n    }\n\n    // Any output after our health check counts as alive\n    // Specifically look for ALIVE keyword for explicit response\n    return strings.Contains(output, &quot;ALIVE&quot;)\n}</code></pre>\n</p>\n<h2>Dog Implementation</h2>\n<h3>Not Reusing Polecat Infrastructure</h3>\n<strong>Decision</strong>: Dogs do NOT reuse polecat infrastructure.\n<p>\nRationale:\n</p>\n<ul><li>Polecats are Claude sessions with molecules, hooks, sandboxes</li>\n<li>Dogs are simple state machine executors</li>\n<li>Polecats have 3-layer lifecycle (session/sandbox/slot)</li>\n<li>Dogs have single-layer lifecycle (just state)</li>\n<li>Different resource profiles, different management</li>\n</ul>\n<p>\nWhat dogs DO share:\n</p>\n<ul><li>tmux utilities for message sending/capture</li>\n<li>State file patterns</li>\n<li>Name slot allocation pattern (pool of names, not instances)</li>\n</ul>\n<h3>Dog Execution Loop</h3>\n<p>\n<pre><code class=\"language-go\">func (d *Dog) Run(ctx context.Context) DogResult {\n    d.State = StateInterrogating\n    d.saveState()\n\n    for d.Attempt &lt;= 3 {\n        // Send interrogation message\n        if err := d.sendHealthCheck(); err != nil {\n            return d.fail(err)\n        }\n\n        // Wait for timeout or context cancellation\n        timeout := d.timeoutForAttempt(d.Attempt)\n        select {\n        case &lt;-ctx.Done():\n            return d.fail(ctx.Err())\n        case &lt;-time.After(timeout):\n            // Timeout reached\n        }\n\n        // Evaluate response\n        d.State = StateEvaluating\n        d.saveState()\n\n        if d.CheckForResponse() {\n            // Session is alive\n            return d.pardon()\n        }\n\n        // No response - try again or execute\n        d.Attempt++\n        if d.Attempt &lt;= 3 {\n            d.State = StateInterrogating\n            d.saveState()\n        }\n    }\n\n    // All attempts exhausted - execute warrant\n    return d.execute()\n}</code></pre>\n</p>\n<h2>Failure Handling</h2>\n<h3>Dog Crashes Mid-Dance</h3>\n<p>\nIf a dog crashes (Boot process restarts, system crash):\n</p>\n<ol><li>State files persist in <code>~/gt/deacon/dogs/active/</code></li>\n<li>On Boot restart, scan for orphaned state files</li>\n<li>Resume or restart based on state:</li>\n</ol>\n<table><tr><td>State</td><td>Recovery Action</td></tr>\n</table>\n<table><tr><td>interrogating</td><td>Restart from current attempt</td></tr>\n<tr><td>evaluating</td><td>Check response, continue</td></tr>\n<tr><td>executing</td><td>Verify kill, mark complete</td></tr>\n<tr><td>pardoned/complete</td><td>Already done, clean up</td></tr>\n</table>\n<p>\n<pre><code class=\"language-go\">func (p *DogPool) RecoverOrphans() error {\n    files, _ := filepath.Glob(p.stateDir + &quot;/*.json&quot;)\n    for _, f := range files {\n        state := loadDogState(f)\n        if state.State != StateComplete &amp;&amp; state.State != StatePardoned {\n            dog := p.allocateForRecovery(state)\n            go dog.Resume()\n        }\n    }\n    return nil\n}</code></pre>\n</p>\n<h3>Handling Pool Exhaustion</h3>\n<p>\nIf all dogs are busy when new warrant arrives:\n</p>\n<p>\n<pre><code class=\"language-go\">func (b *Boot) HandleWarrant(warrant *Warrant) error {\n    dog, err := b.pool.Allocate(warrant)\n    if err == ErrPoolExhausted {\n        // Queue the warrant for later processing\n        b.warrantQueue.Push(warrant)\n        b.log(&quot;Warrant %s queued (pool exhausted)&quot;, warrant.ID)\n        return nil\n    }\n\n    go func() {\n        result := dog.Run(b.ctx)\n        b.handleResult(result)\n        b.pool.Release(dog)\n\n        // Check queue for pending warrants\n        if next := b.warrantQueue.Pop(); next != nil {\n            b.HandleWarrant(next)\n        }\n    }()\n\n    return nil\n}</code></pre>\n</p>\n<h2>Directory Structure</h2>\n<p>\n<pre><code class=\"language-text\">~/gt/deacon/dogs/\n├── boot/                    # Boot's working directory\n│   ├── CLAUDE.md            # Boot context\n│   └── .boot-status.json    # Boot execution status\n├── active/                  # Active dog state files\n│   ├── dog-123.json         # Dog 1 state\n│   ├── dog-456.json         # Dog 2 state\n│   └── ...\n├── completed/               # Completed dance records (for audit)\n│   ├── dog-789.json         # Historical record\n│   └── ...\n└── warrants/                # Pending warrant queue\n    ├── warrant-abc.json\n    └── ...</code></pre>\n</p>\n<h2>Command Interface</h2>\n<p>\n<pre><code class=\"language-bash\"># Pool status\ngt dog pool status\n# Output:\n# Dog Pool: 3/5 active\n#   dog-123: interrogating Toast (attempt 2, 45s remaining)\n#   dog-456: executing Shadow\n#   dog-789: idle\n\n# Manual dog operations (for debugging)\ngt dog pool allocate &lt;warrant-id&gt;\ngt dog pool release &lt;dog-id&gt;\n\n# View active dances\ngt dog dances\n# Output:\n# Active Shutdown Dances:\n#   dog-123 → Toast: Interrogating (2/3), timeout in 45s\n#   dog-456 → Shadow: Executing warrant\n\n# View warrant queue\ngt dog warrants\n# Output:\n# Pending Warrants: 2\n#   1. gt-abc: witness-gastown (stuck_no_progress)\n#   2. gt-def: polecat-Copper (crash_loop)</code></pre>\n</p>\n<h2>Integration with Existing Dogs</h2>\n<p>\nThe existing <code>dog</code> package (<code>internal/dog/</code>) manages Deacon's multi-rig helper dogs.\nThose are different from shutdown-dance dogs:\n</p>\n<table><tr><td>Aspect</td><td>Helper Dogs (existing)</td><td>Dance Dogs (new)</td></tr>\n</table>\n<table><tr><td>Purpose</td><td>Cross-rig infrastructure</td><td>Shutdown dance execution</td></tr>\n<tr><td>Sessions</td><td>Claude sessions</td><td>Goroutines (no Claude)</td></tr>\n<tr><td>Worktrees</td><td>One per rig</td><td>None</td></tr>\n<tr><td>Lifecycle</td><td>Long-lived, reusable</td><td>Ephemeral per warrant</td></tr>\n<tr><td>State</td><td>idle/working</td><td>Dance state machine</td></tr>\n</table>\n<strong>Recommendation</strong>: Use different package to avoid confusion:\n<ul><li><code>internal/dog/</code> - existing helper dogs</li>\n<li><code>internal/shutdown/</code> - shutdown dance pool</li>\n</ul>\n<h2>Summary: Answers to Design Questions</h2>\n<table><tr><td>Question</td><td>Answer</td></tr>\n</table>\n<table><tr><td>How many Dogs in pool?</td><td>Fixed: 5 (configurable via GT_DOG_POOL_SIZE)</td></tr>\n<tr><td>How do Dogs communicate with Boot?</td><td>State files + completion markers</td></tr>\n<tr><td>Are Dogs tmux sessions?</td><td>No - goroutines with state machine</td></tr>\n<tr><td>Reuse polecat infrastructure?</td><td>No - too heavyweight, different model</td></tr>\n<tr><td>What if Dog dies mid-dance?</td><td>State file recovery on Boot restart</td></tr>\n</table>\n<h2>Acceptance Criteria</h2>\n<ul><li>[x] Architecture document for Dog pool</li>\n<li>[x] Clear allocation/deallocation protocol</li>\n<li>[x] Failure handling for Dog crashes</li></ul>";
---

<DocsLayout title="Dog Pool Architecture for Concurrent Shutdown Dances" description="> Design document for gt-fsld8">
  <div class="markdown-content" set:html={content} />
</DocsLayout>
