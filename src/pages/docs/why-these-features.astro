---
import DocsLayout from '../../layouts/DocsLayout.astro';

const content = "<p>\n> Gas Town's architecture explained through enterprise AI challenges\n</p>\n<h2>The Problem</h2>\n<p>\nYou have AI agents. Maybe a lot of them. They're writing code, reviewing PRs,\nfixing bugs, adding features. But you can't answer basic questions:\n</p>\n<ul><li><strong>Who did what?</strong> Which agent wrote this buggy code?</li>\n<li><strong>Who's reliable?</strong> Which agents consistently deliver quality?</li>\n<li><strong>Who can do this?</strong> Which agent should handle this Go refactor?</li>\n<li><strong>What's connected?</strong> Does this frontend change depend on a backend PR?</li>\n<li><strong>What's the full picture?</strong> How's the project doing across 12 repos?</li>\n</ul>\n<p>\nTraditional tools don't help. CI/CD tracks builds, not capability. Git tracks\ncommits, not agent performance. Project management tracks tickets, not the\nnuanced reality of who actually did what, and how well.\n</p>\n<h2>The Solution: A Work Ledger</h2>\n<p>\nGas Town treats work as structured data. Every action is recorded. Every agent\nhas a track record. Every piece of work has provenance.\n</p>\n<p>\nThis isn't about surveillance. It's about <strong>visibility</strong> - the same visibility\nyou'd expect from any serious engineering system.\n</p>\n<p>\n---\n</p>\n<h2>Feature: Entity Tracking and Attribution</h2>\n<strong>The problem:</strong> You deploy 50 agents across 10 projects. One of them introduces\n<p>\na critical bug. Which one? Traditional git blame shows a generic \"AI Assistant\"\nor worse, the human's name.\n</p>\n<strong>The solution:</strong> Every Gas Town agent has a distinct identity. Every action is\n<p>\nattributed:\n</p>\n<pre><code class=\"language-text\">Git commits:    gastown/polecats/toast &lt;owner@example.com&gt;\n<p>\nBeads records:  created_by: gastown/crew/joe\nEvent logs:     actor: gastown/polecats/nux</code></pre>\n</p>\n<strong>Why it matters:</strong>\n<ul><li><strong>Debugging:</strong> Trace problems to specific agents</li>\n<li><strong>Compliance:</strong> Audit trails for SOX, GDPR, enterprise policy</li>\n<li><strong>Accountability:</strong> Know exactly who touched what, when</li>\n</ul>\n<p>\n---\n</p>\n<h2>Feature: Work History (Agent CVs)</h2>\n<strong>The problem:</strong> You want to assign a complex Go refactor. You have 20 agents.\n<p>\nSome are great at Go. Some have never touched it. Some are flaky. How do you\nchoose?\n</p>\n<strong>The solution:</strong> Every agent accumulates a work history:\n<pre><code class=\"language-bash\"># What has this agent done?\n<p>\nbd audit --actor=gastown/polecats/toast\n</p>\n<h1>Success rate on Go projects</h1>\n<p>\nbd stats --actor=gastown/polecats/toast --tag=go</code></pre>\n</p>\n<strong>Why it matters:</strong>\n<ul><li><strong>Performance management:</strong> Objective data on agent reliability</li>\n<li><strong>Capability matching:</strong> Route work to proven agents</li>\n<li><strong>Continuous improvement:</strong> Identify underperforming agents for tuning</li>\n</ul>\n<p>\nThis is particularly valuable when <strong>A/B testing models</strong>. Deploy Claude vs GPT\non similar tasks, track their completion rates and quality, make informed decisions.\n</p>\n<p>\n---\n</p>\n<h2>Feature: Capability-Based Routing</h2>\n<strong>The problem:</strong> You have work in Go, Python, TypeScript, Rust. You have agents\n<p>\nwith varying capabilities. Manual assignment doesn't scale.\n</p>\n<strong>The solution:</strong> Work carries skill requirements. Agents have demonstrated\n<p>\ncapabilities (derived from their work history). Matching is automatic:\n</p>\n<pre><code class=\"language-bash\"># Agent capabilities (derived from work history)\n<p>\nbd skills gastown/polecats/toast\n</p>\n<h1>→ go: 47 tasks, python: 12 tasks, typescript: 3 tasks</h1>\n<h1>Route based on fit</h1>\n<p>\ngt dispatch gt-xyz --prefer-skill=go</code></pre>\n</p>\n<strong>Why it matters:</strong>\n<ul><li><strong>Efficiency:</strong> Right agent for the right task</li>\n<li><strong>Quality:</strong> Agents work in their strengths</li>\n<li><strong>Scale:</strong> No human bottleneck on assignment</li>\n</ul>\n<p>\n---\n</p>\n<h2>Feature: Recursive Work Decomposition</h2>\n<strong>The problem:</strong> Enterprise projects are complex. A \"feature\" becomes 50 tasks\n<p>\nacross 8 repos involving 4 teams. Flat issue lists don't capture this structure.\n</p>\n<strong>The solution:</strong> Work decomposes naturally:\n<pre><code class=\"language-text\">Epic: User Authentication System\n<p>\n├── Feature: Login Flow\n│   ├── Task: API endpoint\n│   ├── Task: Frontend component\n│   └── Task: Integration tests\n├── Feature: Session Management\n│   └── ...\n└── Feature: Password Reset\n    └── ...</code></pre>\n</p>\n<p>\nEach level has its own chain. Roll-ups are automatic. You always know where\nyou stand.\n</p>\n<strong>Why it matters:</strong>\n<ul><li><strong>Visibility:</strong> See the forest and the trees</li>\n<li><strong>Coordination:</strong> Dependencies are explicit</li>\n<li><strong>Progress tracking:</strong> Accurate status at every level</li>\n</ul>\n<p>\n---\n</p>\n<h2>Feature: Cross-Project References</h2>\n<strong>The problem:</strong> Your frontend can't ship until the backend API lands. They're\n<p>\nin different repos. Traditional tools don't track this.\n</p>\n<strong>The solution:</strong> Explicit cross-project dependencies:\n<pre><code class=\"language-text\">depends_on:\n<p>\n  beads://github/acme/backend/be-456  # Backend API\n  beads://github/acme/shared/sh-789   # Shared types</code></pre>\n</p>\n<strong>Why it matters:</strong>\n<ul><li><strong>No surprises:</strong> You know what's blocking</li>\n<li><strong>Coordination:</strong> Teams see their impact on others</li>\n<li><strong>Planning:</strong> Realistic schedules based on actual dependencies</li>\n</ul>\n<p>\n---\n</p>\n<h2>Feature: Federation</h2>\n<strong>The problem:</strong> Enterprise projects span multiple repositories, multiple teams,\n<p>\nsometimes multiple organizations (contractors, partners). Visibility is fragmented.\n</p>\n<strong>The solution:</strong> Federated workspaces that reference each other:\n<pre><code class=\"language-bash\"># Register remote workspace\n<p>\ngt remote add partner hop://partner.com/their-project\n</p>\n<h1>Query across workspaces</h1>\n<p>\nbd list --remote=partner --tag=integration</code></pre>\n</p>\n<strong>Why it matters:</strong>\n<ul><li><strong>Enterprise scale:</strong> Not limited to single-repo thinking</li>\n<li><strong>Contractor coordination:</strong> Track delegated work</li>\n<li><strong>Distributed teams:</strong> Unified view despite separate repos</li>\n</ul>\n<p>\n---\n</p>\n<h2>Feature: Validation and Quality Gates</h2>\n<strong>The problem:</strong> An agent says \"done.\" Is it actually done? Is the code quality\n<p>\nacceptable? Did it pass review?\n</p>\n<strong>The solution:</strong> Structured validation with attribution:\n<pre><code class=\"language-json\">{\n<p>\n  &quot;validated_by&quot;: &quot;gastown/refinery&quot;,\n  &quot;validation_type&quot;: &quot;merge&quot;,\n  &quot;timestamp&quot;: &quot;2025-01-15T10:30:00Z&quot;,\n  &quot;quality_signals&quot;: {\n    &quot;tests_passed&quot;: true,\n    &quot;review_approved&quot;: true,\n    &quot;lint_clean&quot;: true\n  }\n}</code></pre>\n</p>\n<strong>Why it matters:</strong>\n<ul><li><strong>Quality control:</strong> Don't trust, verify</li>\n<li><strong>Audit trails:</strong> Who approved what, when</li>\n<li><strong>Process enforcement:</strong> Gates are data, not just policy</li>\n</ul>\n<p>\n---\n</p>\n<h2>Feature: Real-Time Activity Feed</h2>\n<strong>The problem:</strong> Complex multi-agent work is opaque. You don't know what's\n<p>\nhappening until it's done (or failed).\n</p>\n<strong>The solution:</strong> Work state as a real-time stream:\n<pre><code class=\"language-bash\">bd activity --follow\n<p>\n[14:32:08] + patrol-x7k.arm-ace bonded (5 steps)\n[14:32:09] → patrol-x7k.arm-ace.capture in_progress\n[14:32:10] ✓ patrol-x7k.arm-ace.capture completed\n[14:32:14] ✓ patrol-x7k.arm-ace.decide completed\n[14:32:17] ✓ patrol-x7k.arm-ace COMPLETE</code></pre>\n</p>\n<strong>Why it matters:</strong>\n<ul><li><strong>Debugging in real-time:</strong> See problems as they happen</li>\n<li><strong>Status awareness:</strong> Always know what's running</li>\n<li><strong>Pattern recognition:</strong> Spot bottlenecks and inefficiencies</li>\n</ul>\n<p>\n---\n</p>\n<h2>The Enterprise Value Proposition</h2>\n<p>\nGas Town is a developer tool - like an IDE, but for AI orchestration. However,\nthe architecture provides enterprise-grade foundations:\n</p>\n<table><tr><td>Capability</td><td>Developer Benefit</td><td>Enterprise Benefit</td></tr>\n</table>\n<table><tr><td>Attribution</td><td>Debug agent issues</td><td>Compliance audits</td></tr>\n<tr><td>Work history</td><td>Tune agent assignments</td><td>Performance management</td></tr>\n<tr><td>Skill routing</td><td>Faster task completion</td><td>Resource optimization</td></tr>\n<tr><td>Federation</td><td>Multi-repo projects</td><td>Cross-org visibility</td></tr>\n<tr><td>Validation</td><td>Quality assurance</td><td>Process enforcement</td></tr>\n<tr><td>Activity feed</td><td>Real-time debugging</td><td>Operational awareness</td></tr>\n</table>\n<strong>For model evaluation:</strong> Deploy different models on comparable tasks, track\n<p>\noutcomes objectively, make data-driven decisions about which models to use where.\n</p>\n<strong>For long-horizon projects:</strong> See how agents perform not just on single tasks,\n<p>\nbut across complex, multi-phase, cross-functional initiatives.\n</p>\n<strong>For cross-functional teams:</strong> Unified visibility across repos, teams, and\n<p>\neven organizations.\n</p>\n<p>\n---\n</p>\n<h2>Design Philosophy</h2>\n<p>\nThese features aren't bolted on. They're foundational:\n</p>\n<p>\n1. <strong>Attribution is not optional.</strong> Every action has an actor.\n2. <strong>Work is data.</strong> Not just tickets - structured, queryable data.\n3. <strong>History matters.</strong> Track records determine trust.\n4. <strong>Scale is assumed.</strong> Multi-repo, multi-agent, multi-org from day one.\n5. <strong>Verification over trust.</strong> Quality gates are first-class primitives.\n</p>\n<p>\nGas Town is built to answer the questions enterprises will ask as AI agents\nbecome central to their engineering workflows.\n</p>";
---

<DocsLayout title="Why These Features?" description="> Gas Town's architecture explained through enterprise AI challenges">
  <div class="markdown-content" set:html={content} />
</DocsLayout>
