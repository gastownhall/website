---
import DocsLayout from '../../../layouts/DocsLayout.astro';

const content = "<p>\n> Understanding the three-layer architecture of polecat workers\n</p>\n<h2>Overview</h2>\n<p>\nPolecats have three distinct lifecycle layers that operate independently. Confusing\nthese layers leads to \"heresies\" like thinking there are \"idle polecats\" and\nmisunderstanding when recycling occurs.\n</p>\n<h2>The Three Operating States</h2>\n<p>\nPolecats have exactly three operating states. There is <strong>no idle pool</strong>.\n</p>\n<table><tr><td>State</td><td>Description</td><td>How it happens</td></tr>\n</table>\n<table><tr><td><strong>Working</strong></td><td>Actively doing assigned work</td><td>Normal operation</td></tr>\n<tr><td><strong>Stalled</strong></td><td>Session stopped mid-work</td><td>Interrupted, crashed, or timed out without being nudged</td></tr>\n<tr><td><strong>Zombie</strong></td><td>Completed work but failed to die</td><td><code>gt done</code> failed during cleanup</td></tr>\n</table>\n<strong>The key distinction:</strong> Zombies completed their work; stalled polecats did not.\n<ul><li><strong>Stalled</strong> = supposed to be working, but stopped. The polecat was interrupted or</li>\n</ul>  crashed and was never nudged back to life. Work is incomplete.\n<ul><li><strong>Zombie</strong> = finished work, tried to exit via <code>gt done</code>, but cleanup failed. The</li>\n</ul>  session should have shut down but didn't. Work is complete, just stuck in limbo.\n<p>\nThere is no \"idle\" state. Polecats don't wait around between tasks. When work is\ndone, <code>gt done</code> shuts down the session. If you see a non-working polecat, something\nis broken.\n</p>\n<h2>The Self-Cleaning Polecat Model</h2>\n<strong>Polecats are responsible for their own cleanup.</strong> When a polecat completes its\n<p>\nwork unit, it:\n</p>\n<p>\n1. Signals completion via <code>gt done</code>\n2. Exits its session immediately (no idle waiting)\n3. Requests its own nuke (self-delete)\n</p>\n<p>\nThis removes dependency on the Witness/Deacon for cleanup and ensures polecats\nnever sit idle. The simple model: <strong>sandbox dies with session</strong>.\n</p>\n<h3>Why Self-Cleaning?</h3>\n<ul><li><strong>No idle polecats</strong> - There's no state where a polecat exists without work</li>\n<li><strong>Reduced watchdog overhead</strong> - Deacon patrols for stalled/zombie polecats, not idle ones</li>\n<li><strong>Faster turnover</strong> - Resources freed immediately on completion</li>\n<li><strong>Simpler mental model</strong> - Done means gone</li>\n</ul>\n<h3>What About Pending Merges?</h3>\n<p>\nThe Refinery owns the merge queue. Once <code>gt done</code> submits work:\n</p>\n<ul><li>The branch is pushed to origin</li>\n<li>Work exists in the MQ, not in the polecat</li>\n<li>If rebase fails, Refinery re-implements on new baseline (fresh polecat)</li>\n<li>The original polecat is already gone - no sending work \"back\"</li>\n</ul>\n<h2>The Three Layers</h2>\n<table><tr><td>Layer</td><td>Component</td><td>Lifecycle</td><td>Persistence</td></tr>\n</table>\n<table><tr><td><strong>Session</strong></td><td>Claude (tmux pane)</td><td>Ephemeral</td><td>Cycles per step/handoff</td></tr>\n<tr><td><strong>Sandbox</strong></td><td>Git worktree</td><td>Persistent</td><td>Until nuke</td></tr>\n<tr><td><strong>Slot</strong></td><td>Name from pool</td><td>Persistent</td><td>Until nuke</td></tr>\n</table>\n<h3>Session Layer</h3>\n<p>\nThe Claude session is <strong>ephemeral</strong>. It cycles frequently:\n</p>\n<ul><li>After each molecule step (via <code>gt handoff</code>)</li>\n<li>On context compaction</li>\n<li>On crash/timeout</li>\n<li>After extended work periods</li>\n</ul>\n<strong>Key insight:</strong> Session cycling is <strong>normal operation</strong>, not failure. The polecat\n<p>\ncontinues working—only the Claude context refreshes.\n</p>\n<pre><code class=\"language-text\">Session 1: Steps 1-2 → handoff\n<p>\nSession 2: Steps 3-4 → handoff\nSession 3: Step 5 → gt done</code></pre>\n</p>\n<p>\nAll three sessions are the <strong>same polecat</strong>. The sandbox and slot persist throughout.\n</p>\n<h3>Sandbox Layer</h3>\n<p>\nThe sandbox is the <strong>git worktree</strong>—the polecat's working directory:\n</p>\n<pre><code class=\"language-text\">~/gt/gastown/polecats/Toast/</code></pre>\n<p>\nThis worktree:\n</p>\n<ul><li>Exists from <code>gt sling</code> until <code>gt polecat nuke</code></li>\n<li>Survives all session cycles</li>\n<li>Contains uncommitted work, staged changes, branch state</li>\n<li>Is independent of other polecat sandboxes</li>\n</ul>\n<p>\nThe Witness never destroys sandboxes mid-work. Only <code>nuke</code> removes them.\n</p>\n<h3>Slot Layer</h3>\n<p>\nThe slot is the <strong>name allocation</strong> from the polecat pool:\n</p>\n<pre><code class=\"language-bash\"># Pool: [Toast, Shadow, Copper, Ash, Storm...]\n<h1>Toast is allocated to work gt-abc</code></pre></h1>\n<p>\nThe slot:\n</p>\n<ul><li>Determines the sandbox path (<code>polecats/Toast/</code>)</li>\n<li>Maps to a tmux session (<code>gt-gastown-Toast</code>)</li>\n<li>Appears in attribution (<code>gastown/polecats/Toast</code>)</li>\n<li>Is released only on nuke</li>\n</ul>\n<h2>Correct Lifecycle</h2>\n<pre><code class=\"language-text\">┌─────────────────────────────────────────────────────────────┐\n<p>\n│                        gt sling                             │\n│  → Allocate slot from pool (Toast)                         │\n│  → Create sandbox (worktree on new branch)                 │\n│  → Start session (Claude in tmux)                          │\n│  → Hook molecule to polecat                                │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                     Work Happens                            │\n│                                                             │\n│  Session cycles happen here:                               │\n│  - gt handoff between steps                                │\n│  - Compaction triggers respawn                             │\n│  - Crash → Witness respawns                                │\n│                                                             │\n│  Sandbox persists through ALL session cycles               │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                  gt done (self-cleaning)                    │\n│  → Push branch to origin                                   │\n│  → Submit work to merge queue (MR bead)                    │\n│  → Request self-nuke (sandbox + session cleanup)           │\n│  → Exit immediately                                        │\n│                                                             │\n│  Work now lives in MQ, not in polecat.                     │\n│  Polecat is GONE. No idle state.                           │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                   Refinery: merge queue                     │\n│  → Rebase and merge to main                                │\n│  → Close the issue                                         │\n│  → If conflict: spawn FRESH polecat to re-implement        │\n│    (never send work back to original polecat - it's gone)  │\n└─────────────────────────────────────────────────────────────┘</code></pre>\n</p>\n<h2>What \"Recycle\" Means</h2>\n<strong>Session cycling</strong>: Normal. Claude restarts, sandbox stays, slot stays.\n<pre><code class=\"language-bash\">gt handoff  # Session cycles, polecat continues</code></pre>\n<strong>Sandbox recreation</strong>: Repair only. Should be rare.\n<pre><code class=\"language-bash\">gt polecat repair Toast  # Emergency: recreate corrupted worktree</code></pre>\n<p>\nSession cycling happens constantly. Sandbox recreation should almost never happen\nduring normal operation.\n</p>\n<h2>Anti-Patterns</h2>\n<h3>\"Idle\" Polecats (They Don't Exist)</h3>\n<strong>Myth:</strong> Polecats wait between tasks in an idle pool.\n<strong>Reality:</strong> There is no idle state. Polecats don't exist without work:\n<p>\n1. Work assigned → polecat spawned\n2. Work done → <code>gt done</code> → session exits → polecat nuked\n3. There is no step 3 where they wait around\n</p>\n<p>\nIf you see a non-working polecat, it's in a <strong>failure state</strong>:\n</p>\n<table><tr><td>What you see</td><td>What it is</td><td>What went wrong</td></tr>\n</table>\n<table><tr><td>Session exists but not working</td><td><strong>Stalled</strong></td><td>Interrupted/crashed, never nudged</td></tr>\n<tr><td>Session done but didn't exit</td><td><strong>Zombie</strong></td><td><code>gt done</code> failed during cleanup</td></tr>\n</table>\n<p>\nDon't call these \"idle\" - that implies they're waiting for work. They're not.\nA stalled polecat is <em>supposed</em> to be working. A zombie is <em>supposed</em> to be dead.\n</p>\n<h3>Manual State Transitions</h3>\n<strong>Anti-pattern:</strong>\n<pre><code class=\"language-bash\">gt polecat done Toast    # DON'T: external state manipulation\n<p>\ngt polecat reset Toast   # DON'T: manual lifecycle control</code></pre>\n</p>\n<strong>Correct:</strong>\n<pre><code class=\"language-bash\"># Polecat signals its own completion:\n<p>\ngt done  # (from inside the polecat session)\n</p>\n<h1>Only Witness nukes polecats:</h1>\n<p>\ngt polecat nuke Toast  # (from Witness, after verification)</code></pre>\n</p>\n<p>\nPolecats manage their own session lifecycle. The Witness manages sandbox lifecycle.\nExternal manipulation bypasses verification.\n</p>\n<h3>Sandboxes Without Work (Stalled Polecats)</h3>\n<strong>Anti-pattern:</strong> A sandbox exists but no molecule is hooked, or the session isn't running.\n<p>\nThis is a <strong>stalled</strong> polecat. It means:\n</p>\n<ul><li>The session crashed and wasn't nudged back to life</li>\n<li>The hook was lost during a crash</li>\n<li>State corruption occurred</li>\n</ul>\n<p>\nThis is NOT an \"idle\" polecat waiting for work. It's stalled - supposed to be\nworking but stopped unexpectedly.\n</p>\n<strong>Recovery:</strong>\n<pre><code class=\"language-bash\"># From Witness:\n<p>\ngt polecat nuke Toast        # Clean up the stalled polecat\ngt sling gt-abc gastown      # Respawn with fresh polecat</code></pre>\n</p>\n<h3>Confusing Session with Sandbox</h3>\n<strong>Anti-pattern:</strong> Thinking session restart = losing work.\n<pre><code class=\"language-bash\"># Session ends (handoff, crash, compaction)\n<h1>Work is NOT lost because:</h1>\n<h1>- Git commits persist in sandbox</h1>\n<h1>- Staged changes persist in sandbox</h1>\n<h1>- Molecule state persists in beads</h1>\n<h1>- Hook persists across sessions</code></pre></h1>\n<p>\nThe new session picks up where the old one left off via <code>gt prime</code>.\n</p>\n<h2>Session Lifecycle Details</h2>\n<p>\nSessions cycle for these reasons:\n</p>\n<table><tr><td>Trigger</td><td>Action</td><td>Result</td></tr>\n</table>\n<table><tr><td><code>gt handoff</code></td><td>Voluntary</td><td>Clean cycle to fresh context</td></tr>\n<tr><td>Context compaction</td><td>Automatic</td><td>Forced by Claude Code</td></tr>\n<tr><td>Crash/timeout</td><td>Failure</td><td>Witness respawns</td></tr>\n<tr><td><code>gt done</code></td><td>Completion</td><td>Session exits, Witness takes over</td></tr>\n</table>\n<p>\nAll except <code>gt done</code> result in continued work. Only <code>gt done</code> signals completion.\n</p>\n<h2>Witness Responsibilities</h2>\n<p>\nThe Witness monitors polecats but does NOT:\n</p>\n<ul><li>Force session cycles (polecats self-manage via handoff)</li>\n<li>Interrupt mid-step (unless truly stuck)</li>\n<li>Nuke polecats (polecats self-nuke via <code>gt done</code>)</li>\n</ul>\n<p>\nThe Witness DOES:\n</p>\n<ul><li>Detect and nudge stalled polecats (sessions that stopped unexpectedly)</li>\n<li>Clean up zombie polecats (sessions where <code>gt done</code> failed)</li>\n<li>Respawn crashed sessions</li>\n<li>Handle escalations from stuck polecats (polecats that explicitly asked for help)</li>\n</ul>\n<h2>Polecat Identity</h2>\n<strong>Key insight:</strong> Polecat <em>identity</em> is long-lived; only sessions and sandboxes are ephemeral.\n<p>\nIn the HOP model, every entity has a chain (CV) that tracks:\n</p>\n<ul><li>What work they've done</li>\n<li>Success/failure rates</li>\n<li>Skills demonstrated</li>\n<li>Quality metrics</li>\n</ul>\n<p>\nThe polecat <em>name</em> (Toast, Shadow, etc.) is a slot from a pool - truly ephemeral.\nBut the <em>agent identity</em> that executes as that polecat accumulates a work history.\n</p>\n<pre><code class=\"language-text\">POLECAT IDENTITY (persistent)     SESSION (ephemeral)     SANDBOX (ephemeral)\n<p>\n├── CV chain                      ├── Claude instance     ├── Git worktree\n├── Work history                  ├── Context window      ├── Branch\n├── Skills demonstrated           └── Dies on handoff     └── Dies on gt done\n└── Credit for work                   or gt done</code></pre>\n</p>\n<p>\nThis distinction matters for:\n</p>\n<ul><li><strong>Attribution</strong> - Who gets credit for the work?</li>\n<li><strong>Skill routing</strong> - Which agent is best for this task?</li>\n<li><strong>Cost accounting</strong> - Who pays for inference?</li>\n<li><strong>Federation</strong> - Agents having their own chains in a distributed world</li>\n</ul>\n<h2>Related Documentation</h2>\n<ul><li><a href=\"../overview.md\">Overview</a> - Role taxonomy and architecture</li>\n<li><a href=\"molecules.md\">Molecules</a> - Molecule execution and polecat workflow</li>\n<li><a href=\"propulsion-principle.md\">Propulsion Principle</a> - Why work triggers immediate execution</li></ul>";
---

<DocsLayout title="Polecat Lifecycle" description="> Understanding the three-layer architecture of polecat workers">
  <div class="markdown-content" set:html={content} />
</DocsLayout>
